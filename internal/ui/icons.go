// Contains icons for the Markdown editor toolbar buttons
package ui

import (
	"fmt"

	"fyne.io/fyne/v2"
)

var ICON_ASSETS = make(map[string][]byte)
var exampleBytes = make([]byte, 1024)

// FIXME: preload icon assets somehow
func init() {
	ICON_ASSETS["h1.png"] = exampleBytes
	ICON_ASSETS["h2.png"] = exampleBytes
	ICON_ASSETS["h3.png"] = exampleBytes
	ICON_ASSETS["bold.png"] = exampleBytes
	ICON_ASSETS["italic.png"] = exampleBytes
	ICON_ASSETS["link.png"] = exampleBytes
	ICON_ASSETS["image.png"] = exampleBytes
	ICON_ASSETS["quote-block.png"] = exampleBytes
	ICON_ASSETS["code-block.png"] = exampleBytes
	ICON_ASSETS["page-break.png"] = exampleBytes
	ICON_ASSETS["undo.png"] = exampleBytes
	ICON_ASSETS["redo.png"] = exampleBytes
}

// ToolbarIcons is the set of icons for the Markdown editor toolbar
type ToolbarIcons struct {
	H1Icon         fyne.Resource
	H2Icon         fyne.Resource
	H3Icon         fyne.Resource
	BoldIcon       fyne.Resource
	ItalicIcon     fyne.Resource
	LinkIcon       fyne.Resource
	ImageIcon      fyne.Resource
	QuoteBlockIcon fyne.Resource
	CodeBlockIcon  fyne.Resource
	PageBreakIcon  fyne.Resource
	UndoIcon       fyne.Resource
	RedoIcon       fyne.Resource
}

// loadIcon loads the data for a single icon file, from the embedded assets directory
func loadIcon(filename string) ([]byte, error) {
	dat, ok := ICON_ASSETS[filename]
	if !ok {
		return []byte{}, fmt.Errorf("icon data not found for %s", filename)
	}
	if len(dat) == 0 {
		return []byte{}, fmt.Errorf("file data is empty for icon: %s", filename)
	}
	return dat, nil
}

// iconResource represents an icon file, with the fyne resource generated by
// the Load method.
type iconResource struct {
	Filename string
	Resource *fyne.StaticResource
}

// Load the icon resource from static files
func (i *iconResource) Load() error {
	data, err := loadIcon(i.Filename)
	if err != nil {
		return err
	}
	i.Resource = fyne.NewStaticResource(i.Filename, data)
	return nil
}

// Load icon resources and returns a populated ToolbarIcons instance
func (t ToolbarIcons) Load() (ToolbarIcons, error) {
	// todo -- something here to load these by name instead of redundantly assigning variables
	h1Icon := &iconResource{Filename: "h1.png"}
	h2Icon := &iconResource{Filename: "h2.png"}
	h3Icon := &iconResource{Filename: "h3.png"}
	boldIcon := &iconResource{Filename: "bold.png"}
	italicIcon := &iconResource{Filename: "italic.png"}
	linkIcon := &iconResource{Filename: "link.png"}
	imageIcon := &iconResource{Filename: "image.png"}
	quoteBlockIcon := &iconResource{Filename: "quote-block.png"}
	codeBlockIcon := &iconResource{Filename: "code-block.png"}
	pageBreakIcon := &iconResource{Filename: "page-break.png"}
	undoIcon := &iconResource{Filename: "undo.png"}
	redoIcon := &iconResource{Filename: "redo.png"}

	for _, ico := range []*iconResource{
		h1Icon,
		h2Icon,
		h3Icon,
		boldIcon,
		italicIcon,
		linkIcon,
		imageIcon,
		quoteBlockIcon,
		codeBlockIcon,
		pageBreakIcon,
		undoIcon,
		redoIcon,
	} {
		err := ico.Load()
		if err != nil {
			return ToolbarIcons{}, err
		}
	}
	return ToolbarIcons{
		H1Icon:         h1Icon.Resource,
		H2Icon:         h2Icon.Resource,
		H3Icon:         h3Icon.Resource,
		BoldIcon:       boldIcon.Resource,
		ItalicIcon:     italicIcon.Resource,
		LinkIcon:       linkIcon.Resource,
		ImageIcon:      imageIcon.Resource,
		QuoteBlockIcon: quoteBlockIcon.Resource,
		CodeBlockIcon:  codeBlockIcon.Resource,
		PageBreakIcon:  pageBreakIcon.Resource,
		UndoIcon:       undoIcon.Resource,
		RedoIcon:       redoIcon.Resource,
	}, nil
}
